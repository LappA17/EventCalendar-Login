import moment from 'moment';
import { Moment } from 'moment';

export const rules = {
	required: (message: string = 'Обязательное поле') => ({
		required: true,
		message,
	}),
	isDateAfter: (message: string) => () => ({
		validator(_: any, value: Moment) {
			//сравним дату которая пришла с datepicker с текущей датой
			if (value.isSameOrAfter(moment())) {
				return Promise.resolve();
			}
			return Promise.reject(new Error(message));
		},
	}),
};

//required: () => ({}) обрати внимание что у нас required записанна в таком синтаксисе потому что она будет ВОЗВРАЩАТЬ объект
//мы создали эту фцию что бы она венула Объект и этот объект попадет в исходный массив в rules там где Form.Item

// Создадим isDateAfter что бы нельзя было создавать события на прошедщую дату
// Здесь мы воспользуемся механизмом замыкания, что бы помимо фции мы могли принимать некоторое сообщение, то-есть на уровень выше мы принимаем аргументов сообщение(информацию об ошибке). То-есть у нас есть некоторая фция, она принимает сообщение по ошибке и эта фция уже возвращает другую фцию, которая возвращает нужный для нас объект
// isSameOrAfter - дата текущая или будущая
// moment() - получаем текущую дату
// если условие нас удолитворяет то мы промис резолвим, если нет то реджектим и туда передаем уже сообщение об ошибке
